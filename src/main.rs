use chrono::Utc;
use ndarray::{arr3, s, Array, Array3, Axis};
use network_pso::{Info, PSO};
use once_cell::sync::Lazy;
use std::fs::write;
use std::time::{Duration, Instant};
use std::vec;

// sample data
static T: Lazy<[Array3<f64>; 3]> = Lazy::new(|| {
    [
        arr3(&[[[5.018]]]),
        arr3(&[[[10.825], [10.7473125], [10.465]]]),
        Array::from_shape_vec(
            (3, 35, 1),
            vec![
                6.048333333333333f64,
                11.625,
                12.83,
                7.498333333333333,
                8.166666666666668,
                16.433333333333334,
                9.57,
                15.718333333333334,
                6.888333333333334,
                17.078333333333333,
                18.068333333333335,
                11.235000000000001,
                8.388333333333334,
                8.485,
                7.886666666666667,
                10.228333333333333,
                1.6133333333333333,
                15.406666666666666,
                11.366666666666667,
                7.989999999999999,
                4.27,
                9.318333333333333,
                3.1900000000000004,
                10.348333333333333,
                4.078333333333333,
                2.7183333333333333,
                7.041666666666667,
                7.883333333333334,
                5.875,
                9.953333333333333,
                8.296666666666667,
                1.995,
                14.263333333333332,
                11.07,
                13.118333333333334,
                3.4349999999999996,
                9.451666666666668,
                10.656666666666666,
                5.326666666666666,
                5.55,
                14.26,
                8.05,
                13.543333333333333,
                6.961666666666667,
                14.903333333333334,
                15.895000000000001,
                9.061666666666667,
                8.313333333333333,
                6.3116666666666665,
                5.546666666666667,
                7.683333333333334,
                4.278333333333333,
                13.233333333333333,
                8.748333333333333,
                9.173333333333332,
                4.9399999999999995,
                6.77,
                5.618333333333333,
                7.73,
                1.8,
                3.9033333333333333,
                6.866666666666666,
                5.543333333333333,
                3.5349999999999997,
                7.613333333333333,
                5.743333333333333,
                4.136666666666667,
                12.098333333333333,
                8.898333333333333,
                10.945,
                11.358333333333333,
                5.718333333333333,
                4.113333333333333,
                9.471666666666668,
                10.171666666666665,
                2.6616666666666666,
                7.363333333333333,
                3.933333333333333,
                10.221666666666666,
                4.52,
                4.296666666666667,
                7.038333333333333,
                8.683333333333334,
                8.511666666666667,
                16.116666666666667,
                9.453333333333333,
                15.465,
                1.6466666666666667,
                7.123333333333333,
                12.468333333333334,
                12.71,
                11.03,
                15.423333333333334,
                8.29,
                13.401666666666667,
                15.161666666666667,
                17.435000000000002,
                15.008333333333333,
                15.254999999999999,
                18.183333333333334,
                11.466666666666667,
                15.056666666666667,
                2.671666666666667,
                6.3,
                3.9133333333333336,
            ],
        )
        .unwrap(),
    ]
});

static C: Lazy<[Vec<f64>; 3]> = Lazy::new(|| [vec![125.0], vec![181.0], vec![39.0]]);

fn tdt(p: &Info) -> f64 {
    let mut res: f64 = 0.0;
    for x in 0..3 {
        let q = &p.pos[x];
        let mut n_carrier: Array3<f64> = Array::zeros(q.raw_dim());
        for z in 0..q.shape()[2] {
            let q_z = q.index_axis(Axis(2), z);
            let arr = q_z.mapv(|e: i32| ((e as f64) / C[x][z]).ceil());
            n_carrier.slice_mut(s![.., .., z]).assign(&arr);
        }
        res += (&n_carrier * &T[x]).sum();
    }
    res
}
fn main() {
    let demand: i32 = 959;
    let graph_dims = [(1, 1, 1), (1, 3, 1), (3, 35, 1)];
    let mut pso = PSO::new(100, tdt, graph_dims, demand);
    let now = Instant::now();
    let limit = Duration::from_secs(300);
    let mut min_time: Vec<f64> = Vec::<f64>::new();
    min_time.push(pso.best_f);
    // run main cycle here
    let mut cnt: i32 = 0;
    while now.elapsed() < limit {
        pso.main_cycle(cnt);
        min_time.push(pso.best_f);
        cnt += 1;
    }
    let data: Vec<String> = min_time.iter().map(|x| x.to_string()).collect();
    let tmstamp = Utc::now().to_rfc3339();
    let fp1 = format!("{}{}{}", &"./logs/", &tmstamp, &".log");
    write(fp1, data.join(",")).expect("Failed to write logs");
    let fp2 = format!("{}{}{}", &"./soln/intermediate/", &tmstamp, &".vec");
    let mut best_w: String = String::new();
    for i in 0..2 {
        best_w.push_str(&pso.g_best_known.pos[i].to_string());
        best_w.push_str("\n+\n");
    }
    best_w.push_str(&pso.g_best_known.pos[2].to_string());
    write(fp2, best_w).expect("Failed to write solution vector");
}
